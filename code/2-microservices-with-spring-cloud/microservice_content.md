Centralized Configuration

- 1-setting-up-limits-microservice
- 2-creating-hard-coded-limits-microservice
- 3-enhance-limits-microservice-get-configuration-from-application-properties
- 4-setting-up-spring-cloud-config-server
- 5-connect-cloud-config-server-to-local-git-repository
- 6-connect-limits-service-to-spring-cloud-config-server
- 7-configuring-profiles-for-limits-service
- 7-connect-limits-service-to-spring-cloud-config-server-multiple-profiles


Connection between Microservices

- 8-currency-exchange-server
- 9-setting-up-dynamic-port-in-the-response
- 10-configure-jpa-initialize-jpa
- 11-currency-conversion-service
- 12-creating-a-service-for-currency-conversion
- 13-invoking-currency-exchange-from-currency-conversion-microservice
- 14-using-feign-rest-client-for-service-invocation


Service Discovery
- 15-understand-naming-server-and-setting-up-eureka-naming-server
- 16-connect-ccs-ces-microservices


Load Balancing
- 17-eureka-naming-server-load-balancing

Api Gateway
- 18-setting-up-spring-cloud-api-gateway
- 19-enabling-discovery-locator-with-eureka-for-spring-cloud-gateway
- 20-exploring-routes-with-spring-cloud-gateway-v2
- 21-implementing-spring-cloud-gateway-logging-filter

Circuit Breaker
- 22-getting-started-with-circuit-breaker-resilience4j
- 23-playing-with-resilience4j-retry-and-fallback-methods
- 24-playing-with-circuit-breaker-features-of-resilience4j
- 25-exploring-rate-limiting-and-bulkhead-features-of-resilience4j